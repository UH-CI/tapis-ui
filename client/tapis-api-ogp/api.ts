/* eslint-disable */
// tslint:disable
/**
 * Tenants API
 * Manage Tapis Tenants.
 *
 * OpenAPI spec version: 1
 * Contact: cicsupport@tacc.utexas.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

/// <reference path="./custom.d.ts" />

import portableFetch from "portable-fetch";
import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError } from "./runtime";
import { Api } from "./models";

/**
 * SitesApi - fetch parameter creator
 * @export
 */
export const SitesApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Create a site.</p>
		 * @summary Create a site.
		 * @param {Api.NewSite} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createSite(request: Api.NewSite, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createSite.');
			}
			let localVarPath = `/v3/sites`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter['Content-Type'] = 'application/json';

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
			localVarRequestOptions.body =  JSON.stringify(request || {});

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Permenantly delete a site.</p>
		 * @summary Delete a site
		 * @param {string} siteId Unique ID of the site
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteSite(siteId: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'siteId' is not null or undefined
			if (siteId === null || siteId === undefined) {
				throw new RequiredError('siteId', 'Required parameter siteId was null or undefined when calling deleteSite.');
			}
			let localVarPath = `/v3/sites/{site_id}`
				.replace('{site_id}', encodeURIComponent(String(siteId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Get details of a specific site by its id.</p>
		 * @summary Get site details
		 * @param {string} siteId Unique ID of the site
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSite(siteId: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'siteId' is not null or undefined
			if (siteId === null || siteId === undefined) {
				throw new RequiredError('siteId', 'Required parameter siteId was null or undefined when calling getSite.');
			}
			let localVarPath = `/v3/sites/{site_id}`
				.replace('{site_id}', encodeURIComponent(String(siteId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>List sites.</p>
		 * @summary List sites.
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listSites(limit: number | undefined, offset: number | undefined, options: RequestInit = {}): FetchArgs {
			let localVarPath = `/v3/sites`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (limit !== undefined) {
				localVarQueryParameter.append('limit', String(limit));
			}

			if (offset !== undefined) {
				localVarQueryParameter.append('offset', String(offset));
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * SitesApi - functional programming interface
 * @export
 */
export const SitesApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Create a site.</p>
		 * @summary Create a site.
		 * @param {Api.NewSite} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createSite(request: Api.NewSite, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.CreateSite201Response> {
			const localVarFetchArgs = SitesApiFetchParamCreator(configuration).createSite(request, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Permenantly delete a site.</p>
		 * @summary Delete a site
		 * @param {string} siteId Unique ID of the site
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteSite(siteId: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.DeleteSite200Response> {
			const localVarFetchArgs = SitesApiFetchParamCreator(configuration).deleteSite(siteId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Get details of a specific site by its id.</p>
		 * @summary Get site details
		 * @param {string} siteId Unique ID of the site
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSite(siteId: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.GetSite200Response> {
			const localVarFetchArgs = SitesApiFetchParamCreator(configuration).getSite(siteId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>List sites.</p>
		 * @summary List sites.
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listSites(limit: number | undefined, offset: number | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ListSites200Response> {
			const localVarFetchArgs = SitesApiFetchParamCreator(configuration).listSites(limit, offset, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
	}
};

/**
 * SitesApi - factory interface
 * @export
 */
export const SitesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 * <p>Create a site.</p>
		 * @summary Create a site.
		 * @param {Api.NewSite} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createSite(request: Api.NewSite, options?: RequestInit) {
			return SitesApiFp(configuration).createSite(request, options)(fetch, basePath);
		},
		/**
		 * <p>Permenantly delete a site.</p>
		 * @summary Delete a site
		 * @param {string} siteId Unique ID of the site
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteSite(siteId: string, options?: RequestInit) {
			return SitesApiFp(configuration).deleteSite(siteId, options)(fetch, basePath);
		},
		/**
		 * <p>Get details of a specific site by its id.</p>
		 * @summary Get site details
		 * @param {string} siteId Unique ID of the site
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSite(siteId: string, options?: RequestInit) {
			return SitesApiFp(configuration).getSite(siteId, options)(fetch, basePath);
		},
		/**
		 * <p>List sites.</p>
		 * @summary List sites.
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listSites(limit: number | undefined, offset: number | undefined, options?: RequestInit) {
			return SitesApiFp(configuration).listSites(limit, offset, options)(fetch, basePath);
		},
	};
};

/**
 * SitesApi - object-oriented interface
 * @export
 * @class SitesApi
 * @extends {BaseAPI}
 */
export class SitesApi extends BaseAPI {
	/**
	 * <p>Create a site.</p>
	 * @summary Create a site.
	 * @param {Api.NewSite} request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SitesApi
	 */
	public createSite(request: Api.NewSite, options?: RequestInit) {
		return SitesApiFp(this.configuration).createSite(request, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Permenantly delete a site.</p>
	 * @summary Delete a site
	 * @param {string} siteId Unique ID of the site
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SitesApi
	 */
	public deleteSite(siteId: string, options?: RequestInit) {
		return SitesApiFp(this.configuration).deleteSite(siteId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Get details of a specific site by its id.</p>
	 * @summary Get site details
	 * @param {string} siteId Unique ID of the site
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SitesApi
	 */
	public getSite(siteId: string, options?: RequestInit) {
		return SitesApiFp(this.configuration).getSite(siteId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>List sites.</p>
	 * @summary List sites.
	 * @param {number} [limit] limit the number of records returned.
	 * @param {number} [offset] index (offset) to start list.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SitesApi
	 */
	public listSites(limit: number | undefined, offset: number | undefined, options?: RequestInit) {
		return SitesApiFp(this.configuration).listSites(limit, offset, options)(this.fetch, this.basePath);
	}

}
/**
 * TenantsApi - fetch parameter creator
 * @export
 */
export const TenantsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Create an ldap</p>
		 * @summary Create an ldap
		 * @param {Api.NewLDAP} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createLdap(request: Api.NewLDAP, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createLdap.');
			}
			let localVarPath = `/v3/tenants/ldaps`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter['Content-Type'] = 'application/json';

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
			localVarRequestOptions.body =  JSON.stringify(request || {});

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Create an owner</p>
		 * @summary Create an owner
		 * @param {Api.Owner} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOwner(request: Api.Owner, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createOwner.');
			}
			let localVarPath = `/v3/tenants/owners`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter['Content-Type'] = 'application/json';

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
			localVarRequestOptions.body =  JSON.stringify(request || {});

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Create a tenant.</p>
		 * @summary Create a tenant.
		 * @param {Api.NewTenant} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createTenant(request: Api.NewTenant, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createTenant.');
			}
			let localVarPath = `/v3/tenants`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter['Content-Type'] = 'application/json';

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
			localVarRequestOptions.body =  JSON.stringify(request || {});

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Permenantly delete an ldap.</p>
		 * @summary Delete ldap
		 * @param {string} ldapId Unique ID of the ldap
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteLdap(ldapId: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'ldapId' is not null or undefined
			if (ldapId === null || ldapId === undefined) {
				throw new RequiredError('ldapId', 'Required parameter ldapId was null or undefined when calling deleteLdap.');
			}
			let localVarPath = `/v3/tenants/ldaps/{ldap_id}`
				.replace('{ldap_id}', encodeURIComponent(String(ldapId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Permenantly delete an owner.</p>
		 * @summary Delete owner
		 * @param {string} email Email addres of the owner
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOwner(email: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'email' is not null or undefined
			if (email === null || email === undefined) {
				throw new RequiredError('email', 'Required parameter email was null or undefined when calling deleteOwner.');
			}
			let localVarPath = `/v3/tenants/owners/{email}`
				.replace('{email}', encodeURIComponent(String(email)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Permenantly delete a tenant.</p>
		 * @summary Delete a tenant
		 * @param {string} tenantId Unique ID of the tenant
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteTenant(tenantId: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'tenantId' is not null or undefined
			if (tenantId === null || tenantId === undefined) {
				throw new RequiredError('tenantId', 'Required parameter tenantId was null or undefined when calling deleteTenant.');
			}
			let localVarPath = `/v3/tenants/{tenant_id}`
				.replace('{tenant_id}', encodeURIComponent(String(tenantId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Get details of a specific ldap by its id.</p>
		 * @summary Get ldap details
		 * @param {string} ldapId Unique ID of the ldap
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLdap(ldapId: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'ldapId' is not null or undefined
			if (ldapId === null || ldapId === undefined) {
				throw new RequiredError('ldapId', 'Required parameter ldapId was null or undefined when calling getLdap.');
			}
			let localVarPath = `/v3/tenants/ldaps/{ldap_id}`
				.replace('{ldap_id}', encodeURIComponent(String(ldapId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Get details of a specific owner by its email address.</p>
		 * @summary Get owner details
		 * @param {string} email Email address of the owner
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOwner(email: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'email' is not null or undefined
			if (email === null || email === undefined) {
				throw new RequiredError('email', 'Required parameter email was null or undefined when calling getOwner.');
			}
			let localVarPath = `/v3/tenants/owners/{email}`
				.replace('{email}', encodeURIComponent(String(email)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Get details of a specific tenant by its id.</p>
		 * @summary Get tenant details
		 * @param {string} tenantId Unique ID of the tenant
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTenant(tenantId: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'tenantId' is not null or undefined
			if (tenantId === null || tenantId === undefined) {
				throw new RequiredError('tenantId', 'Required parameter tenantId was null or undefined when calling getTenant.');
			}
			let localVarPath = `/v3/tenants/{tenant_id}`
				.replace('{tenant_id}', encodeURIComponent(String(tenantId)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>List ldaps</p>
		 * @summary List ldaps
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listLdaps(limit: number | undefined, offset: number | undefined, options: RequestInit = {}): FetchArgs {
			let localVarPath = `/v3/tenants/ldaps`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (limit !== undefined) {
				localVarQueryParameter.append('limit', String(limit));
			}

			if (offset !== undefined) {
				localVarQueryParameter.append('offset', String(offset));
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>List owners</p>
		 * @summary List owners
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listOwners(limit: number | undefined, offset: number | undefined, options: RequestInit = {}): FetchArgs {
			let localVarPath = `/v3/tenants/owners`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (limit !== undefined) {
				localVarQueryParameter.append('limit', String(limit));
			}

			if (offset !== undefined) {
				localVarQueryParameter.append('offset', String(offset));
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>List tenants.</p>
		 * @summary List tenants.
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listTenants(limit: number | undefined, offset: number | undefined, options: RequestInit = {}): FetchArgs {
			let localVarPath = `/v3/tenants`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: HeadersInit = {};
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (limit !== undefined) {
				localVarQueryParameter.append('limit', String(limit));
			}

			if (offset !== undefined) {
				localVarQueryParameter.append('offset', String(offset));
			}

			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * TenantsApi - functional programming interface
 * @export
 */
export const TenantsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Create an ldap</p>
		 * @summary Create an ldap
		 * @param {Api.NewLDAP} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createLdap(request: Api.NewLDAP, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.CreateLdap201Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).createLdap(request, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Create an owner</p>
		 * @summary Create an owner
		 * @param {Api.Owner} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOwner(request: Api.Owner, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.CreateOwner201Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).createOwner(request, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Create a tenant.</p>
		 * @summary Create a tenant.
		 * @param {Api.NewTenant} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createTenant(request: Api.NewTenant, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.CreateTenant201Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).createTenant(request, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Permenantly delete an ldap.</p>
		 * @summary Delete ldap
		 * @param {string} ldapId Unique ID of the ldap
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteLdap(ldapId: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.DeleteLdap200Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).deleteLdap(ldapId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Permenantly delete an owner.</p>
		 * @summary Delete owner
		 * @param {string} email Email addres of the owner
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOwner(email: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.DeleteOwner200Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).deleteOwner(email, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Permenantly delete a tenant.</p>
		 * @summary Delete a tenant
		 * @param {string} tenantId Unique ID of the tenant
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteTenant(tenantId: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.DeleteTenant200Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).deleteTenant(tenantId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Get details of a specific ldap by its id.</p>
		 * @summary Get ldap details
		 * @param {string} ldapId Unique ID of the ldap
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLdap(ldapId: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.GetLdap200Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).getLdap(ldapId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Get details of a specific owner by its email address.</p>
		 * @summary Get owner details
		 * @param {string} email Email address of the owner
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOwner(email: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.GetOwner200Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).getOwner(email, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>Get details of a specific tenant by its id.</p>
		 * @summary Get tenant details
		 * @param {string} tenantId Unique ID of the tenant
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTenant(tenantId: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.GetTenant200Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).getTenant(tenantId, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>List ldaps</p>
		 * @summary List ldaps
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listLdaps(limit: number | undefined, offset: number | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ListLdaps200Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).listLdaps(limit, offset, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>List owners</p>
		 * @summary List owners
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listOwners(limit: number | undefined, offset: number | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ListOwners200Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).listOwners(limit, offset, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
		/**
		 * <p>List tenants.</p>
		 * @summary List tenants.
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listTenants(limit: number | undefined, offset: number | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.ListTenants200Response> {
			const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).listTenants(limit, offset, options);
			return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json();
					} else {
						throw response;
					}
				});
			};
		},
	}
};

/**
 * TenantsApi - factory interface
 * @export
 */
export const TenantsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 * <p>Create an ldap</p>
		 * @summary Create an ldap
		 * @param {Api.NewLDAP} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createLdap(request: Api.NewLDAP, options?: RequestInit) {
			return TenantsApiFp(configuration).createLdap(request, options)(fetch, basePath);
		},
		/**
		 * <p>Create an owner</p>
		 * @summary Create an owner
		 * @param {Api.Owner} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOwner(request: Api.Owner, options?: RequestInit) {
			return TenantsApiFp(configuration).createOwner(request, options)(fetch, basePath);
		},
		/**
		 * <p>Create a tenant.</p>
		 * @summary Create a tenant.
		 * @param {Api.NewTenant} request
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createTenant(request: Api.NewTenant, options?: RequestInit) {
			return TenantsApiFp(configuration).createTenant(request, options)(fetch, basePath);
		},
		/**
		 * <p>Permenantly delete an ldap.</p>
		 * @summary Delete ldap
		 * @param {string} ldapId Unique ID of the ldap
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteLdap(ldapId: string, options?: RequestInit) {
			return TenantsApiFp(configuration).deleteLdap(ldapId, options)(fetch, basePath);
		},
		/**
		 * <p>Permenantly delete an owner.</p>
		 * @summary Delete owner
		 * @param {string} email Email addres of the owner
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOwner(email: string, options?: RequestInit) {
			return TenantsApiFp(configuration).deleteOwner(email, options)(fetch, basePath);
		},
		/**
		 * <p>Permenantly delete a tenant.</p>
		 * @summary Delete a tenant
		 * @param {string} tenantId Unique ID of the tenant
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteTenant(tenantId: string, options?: RequestInit) {
			return TenantsApiFp(configuration).deleteTenant(tenantId, options)(fetch, basePath);
		},
		/**
		 * <p>Get details of a specific ldap by its id.</p>
		 * @summary Get ldap details
		 * @param {string} ldapId Unique ID of the ldap
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLdap(ldapId: string, options?: RequestInit) {
			return TenantsApiFp(configuration).getLdap(ldapId, options)(fetch, basePath);
		},
		/**
		 * <p>Get details of a specific owner by its email address.</p>
		 * @summary Get owner details
		 * @param {string} email Email address of the owner
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOwner(email: string, options?: RequestInit) {
			return TenantsApiFp(configuration).getOwner(email, options)(fetch, basePath);
		},
		/**
		 * <p>Get details of a specific tenant by its id.</p>
		 * @summary Get tenant details
		 * @param {string} tenantId Unique ID of the tenant
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTenant(tenantId: string, options?: RequestInit) {
			return TenantsApiFp(configuration).getTenant(tenantId, options)(fetch, basePath);
		},
		/**
		 * <p>List ldaps</p>
		 * @summary List ldaps
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listLdaps(limit: number | undefined, offset: number | undefined, options?: RequestInit) {
			return TenantsApiFp(configuration).listLdaps(limit, offset, options)(fetch, basePath);
		},
		/**
		 * <p>List owners</p>
		 * @summary List owners
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listOwners(limit: number | undefined, offset: number | undefined, options?: RequestInit) {
			return TenantsApiFp(configuration).listOwners(limit, offset, options)(fetch, basePath);
		},
		/**
		 * <p>List tenants.</p>
		 * @summary List tenants.
		 * @param {number} [limit] limit the number of records returned.
		 * @param {number} [offset] index (offset) to start list.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listTenants(limit: number | undefined, offset: number | undefined, options?: RequestInit) {
			return TenantsApiFp(configuration).listTenants(limit, offset, options)(fetch, basePath);
		},
	};
};

/**
 * TenantsApi - object-oriented interface
 * @export
 * @class TenantsApi
 * @extends {BaseAPI}
 */
export class TenantsApi extends BaseAPI {
	/**
	 * <p>Create an ldap</p>
	 * @summary Create an ldap
	 * @param {Api.NewLDAP} request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public createLdap(request: Api.NewLDAP, options?: RequestInit) {
		return TenantsApiFp(this.configuration).createLdap(request, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Create an owner</p>
	 * @summary Create an owner
	 * @param {Api.Owner} request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public createOwner(request: Api.Owner, options?: RequestInit) {
		return TenantsApiFp(this.configuration).createOwner(request, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Create a tenant.</p>
	 * @summary Create a tenant.
	 * @param {Api.NewTenant} request
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public createTenant(request: Api.NewTenant, options?: RequestInit) {
		return TenantsApiFp(this.configuration).createTenant(request, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Permenantly delete an ldap.</p>
	 * @summary Delete ldap
	 * @param {string} ldapId Unique ID of the ldap
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public deleteLdap(ldapId: string, options?: RequestInit) {
		return TenantsApiFp(this.configuration).deleteLdap(ldapId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Permenantly delete an owner.</p>
	 * @summary Delete owner
	 * @param {string} email Email addres of the owner
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public deleteOwner(email: string, options?: RequestInit) {
		return TenantsApiFp(this.configuration).deleteOwner(email, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Permenantly delete a tenant.</p>
	 * @summary Delete a tenant
	 * @param {string} tenantId Unique ID of the tenant
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public deleteTenant(tenantId: string, options?: RequestInit) {
		return TenantsApiFp(this.configuration).deleteTenant(tenantId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Get details of a specific ldap by its id.</p>
	 * @summary Get ldap details
	 * @param {string} ldapId Unique ID of the ldap
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public getLdap(ldapId: string, options?: RequestInit) {
		return TenantsApiFp(this.configuration).getLdap(ldapId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Get details of a specific owner by its email address.</p>
	 * @summary Get owner details
	 * @param {string} email Email address of the owner
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public getOwner(email: string, options?: RequestInit) {
		return TenantsApiFp(this.configuration).getOwner(email, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Get details of a specific tenant by its id.</p>
	 * @summary Get tenant details
	 * @param {string} tenantId Unique ID of the tenant
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public getTenant(tenantId: string, options?: RequestInit) {
		return TenantsApiFp(this.configuration).getTenant(tenantId, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>List ldaps</p>
	 * @summary List ldaps
	 * @param {number} [limit] limit the number of records returned.
	 * @param {number} [offset] index (offset) to start list.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public listLdaps(limit: number | undefined, offset: number | undefined, options?: RequestInit) {
		return TenantsApiFp(this.configuration).listLdaps(limit, offset, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>List owners</p>
	 * @summary List owners
	 * @param {number} [limit] limit the number of records returned.
	 * @param {number} [offset] index (offset) to start list.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public listOwners(limit: number | undefined, offset: number | undefined, options?: RequestInit) {
		return TenantsApiFp(this.configuration).listOwners(limit, offset, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>List tenants.</p>
	 * @summary List tenants.
	 * @param {number} [limit] limit the number of records returned.
	 * @param {number} [offset] index (offset) to start list.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TenantsApi
	 */
	public listTenants(limit: number | undefined, offset: number | undefined, options?: RequestInit) {
		return TenantsApiFp(this.configuration).listTenants(limit, offset, options)(this.fetch, this.basePath);
	}

}
